<input type="file" onchange="encodeImageFileAsURL(this)" />
<input type="hidden" name="file_base64" id="file_base64" />

<script>
function encodeImageFileAsURL(element) {
  const file = element.files[0];
  const reader = new FileReader();
  reader.onloadend = function() {
    document.getElementById('file_base64').value = reader.result;
  }
  reader.readAsDataURL(file);
}
</script>

---------------------------------------------------------------------

<?php

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;
use Illuminate\Http\UploadedFile;
use Symfony\Component\HttpFoundation\File\File;

class UploadImageRequest extends FormRequest
{
    public function validationData()
    {
        $all = parent::validationData();

        if ($this->get('file_base64')) {
            // base64をデコード。プレフィックスに「data:image/jpeg;base64,」のような文字列がついている場合は除去して処理する
            $data = explode(',', $this->get('file_base64'));
            if (isset($data[1])) {
                $fileData = base64_decode($data[1]);
            } else {
                $fileData = base64_decode($data[0]);
            }

            // tmp領域に画像ファイルとして保存してUploadedFileとして扱う
            $tmpFilePath = sys_get_temp_dir() . '/' . Str::uuid()->toString();
            file_put_contents($tmpFilePath, $fileData);
            $tmpFile = new File($tmpFilePath);
            $filename = $tmpFile->getFilename();
            if ($this->get('file_name_base64')) {
                // ファイル名の指定があればセット
                $filename = $this->get('file_name_base64');
            }
            $file = new UploadedFile(
                $tmpFile->getPathname(),
                $filename,
                $tmpFile->getMimeType(),
                0,
                true
            );
            $all['file'] = $file;
        }
        return $all;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'file' => 'required_without:file_base64|image|mimes:jpeg|max:5000|dimensions:max_width=1200,max_height=1200,ratio=1/1', // ファイルのバリデーションよしなに。
            'file_base64' => 'required_without:file|string', // ファイルデータをbase64で文字列としても受け入れる。バリデーションルールはfileが適用される。
            // 'file_name_base64' => 'required_with:file_base64|string|max:150', // 必要に応じて
        ];
    }
}

----------------------------------------------------------------

はい、その認識が正確です。
<input type="file">の値はセキュリティ上の理由でJavaScriptから設定できないため、バリデーション失敗後のリダイレクト時に$_REQUEST['image']は空になります。
解決方法として、以下の2つのアプローチがあります：

Base64データを画像ファイルに変換して処理する方法：

public function store(Request $request)
{
    // バリデーション
    $validator = Validator::make($request->all(), [
        'title' => 'required',
        // imageがない場合はtemp_imageをチェック
        'image' => $request->hasFile('image') ? 'image|mimes:jpeg,png,jpg,gif|max:2048' : '',
        'temp_image' => !$request->hasFile('image') ? 'required|string' : ''
    ]);

    if ($validator->fails()) {
        return redirect()->back()
            ->withErrors($validator)
            ->withInput();
    }

    // 画像の処理
    if ($request->hasFile('image')) {
        // 通常のファイルアップロード処理
        $image = $request->file('image');
    } else if ($request->filled('temp_image')) {
        // Base64データを画像に変換
        $base64Image = $request->input('temp_image');
        // Base64のヘッダー部分を削除
        $imageData = substr($base64Image, strpos($base64Image, ',') + 1);
        // バイナリデータに変換
        $imageData = base64_decode($imageData);
        
        // 一時ファイルとして保存
        $tempPath = tempnam(sys_get_temp_dir(), 'uploaded_image_');
        file_put_contents($tempPath, $imageData);
        
        // UploadedFileオブジェクトを作成
        $image = new \Illuminate\Http\UploadedFile(
            $tempPath,
            'uploaded_image.jpg',
            'image/jpeg',
            null,
            true
        );
    }

    // 以降は通常の画像処理
    $path = $image->store('uploads');
    // ...